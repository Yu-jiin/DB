DATABASE        - 체계적인 데이터 모음
DATA            - 저장이나 처리에 효율적인 형태로 변환된 정보
FIELD(column)   - 고유한 데이터 형식이 지정 
RECORD(row)     - 구체적인 데이터값 저장
Primary  Key    - 기본 키 (식별자)
Foreign Key     - 외래키 (기본 키 참조, 서로 다른 테이블 간 관계 생성)

RDBMS           - DB를 관리하는 SW 프로그램
                - ex) SQLite, MySql, OracleDatabase

SQL             - DB에 정보를 저장하고 처리하기 위한 프로그래밍 언어

SQL Syntax
    1. 대소문자를 구분하지 않음 (하지만 대문자 권장)
    2. 각 SQL Statments 끝에는 세미콜론(';') 필요 
        SELECT column_name FROM table_name;
        - SELECT Statement,  SELECT, FROM 2개의 keyword 구성

DDL(구조)    - CREATE, DROP, ALTER
DQL(검색)    - SELECT
DML(조작)    - INSERT, UPDATE, DELETE
DCL(제어)    - COMMIT, ROLLBACK, GRANT, REVOKE

----------------------------------------------------------------

SELECT Statement    - 테이블에서 데이터를 조회

SELECT 
    select_list     - 선택하려는 데이터 필드
FROM
    table_name;     - 어디 테이블인지 이름 지정 

---------------------------------------------------------------

ORDER BY Statement  - 정렬
                    - 설정안하면 오름차순 기본값
FROM 절 뒤에 위치   

ORDER BY
    column1 [ASC|DESC]

SELECT FirstName from employees ORDER BY "FirstName" ASC;

FILTER
    - DISTINCT  중복 제거


SELECT Statement 실행 순서

FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT

----------------------------------------------------------------------------

오후 수업 

DDL - 기본 구조 및 형식 만들기

CREATE TABLE examples (
    -- 테이블 구성 요소
    -- 컬럼명 데이터타입 제약조건,
    ExamID INTEGER PRIMARY KEY AUTOINCREMENT,
    LastName VARCHAR(50) NOT NULL,
    FirstName VARCHAR(50) NOT NULL
);

ALTER TABLE ADD COLUMN      - 필드 추가
ALTER TABLE RENAME column   - 필드 이름 변경
ALTER TABLE DROP column     - 필드 삭제
ALTER TABLE RENAME TO       - 테이블 이름 변경


ALTER TABLE examples
ADD COLUMN Country VARCHAR(100) NOT NULL;

----------------------------------------------------------------

JOIN 관계 

CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name VARCHAR(50) NOT NULL
);

CREATE TABLE articles (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title VARCHAR(50) NOT NULL,
  content VARCHAR(100) NOT NULL,
  userId INTEGER NOT NULL,
  FOREIGN KEY (userId) 
    REFERENCES users(id)
);

-----------------------------------------------------------------

N : 1  /  1 : N
    - 한 테이블의 0개 이상의 레코드가 다른 테이블 레코드 한개와 관련
    - 0개 이상의 댓글은 1개의 게시글에 작성될 수 있음


class Comment(models.Model):
    # 참조하려는 대상의 단수형을 외래키로
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    content = models.CharField(max_length=200)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

CASCADE = 부모객체 삭제 시 자식 객체도 삭제

역참조
article.comment_set.all()
- 특정 게시물에 작성된 댓글 전체 조회 

N : 1 관계에서 생성되는 Related manager 이름은 "모델명_set" 으로 자동 생성
특정 댓글의 게시글 참조         - comment.article
특정 게시글의 댓글 목록 참조    - article.comment_set.all()


    if comment_form.is_valid():
        # 외래키 넣으려면 2개 필요
        # 1. comment 인스턴스 필요
        # 2. save 메서드가 호출 되기 전 
        # 근데 comment instance는 save 메서드가 호출되어야 생성됨 그래서 뭐 하나 만들어줌 장고가
        comment = comment_form.save(commit=False)
        comment.article = article
        comment.save()
        return redirect('articles:detail')
    context = {
        'article' : article,
        'comment_form' : comment_form,
    }
    return render(request, 'articles/detail.html', context)

save의 commit 인자를 활용해서 외래키 추가 !! 



def comments_delete(request, pk):
    comment = Comment.objects.get(pk=pk)
    article_pk = comment.article.pk
    comment.delete()
    return redirect('articles:detail', article_pk)


View decorators = 지정되지않은 method로 요청 들어오면 405 반환

----------------------------------------------------------------

ManyToManyField() - M:N 관계 설정 모델 필드

class Patient(models.Model):
    # ManyToManyFields 작성
    doctors = models.ManyToManyField(Doctor)
    
    name = models.TextField()
    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'

# 양쪽 다  데이터 추가 및 삭제 가능 
patient1.doctors.add(doctor1)
patient1.doctors.all()
doctor1.patient_set.all()


doctor1.patient_set.add(patient2)
doctor1.patient_set.all()
patient2.doctors.all()
patient1.doctors.all()

# doctor가 patient1 진료 예약 취소 역참조로
doctor1.patient_set.remove(patient1)
doctor1.patient_set.all()
patient1.doctors.all()

patient2.patient_set.remove(doctor1)
patient2.doctors.all()
doctor1.patient_set.all()


through argument
    - 중개 테이블에 추가 데이터를 사용해 M : N 관계 형성 

class Doctor(models.Model):
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 의사 {self.name}'


class Patient(models.Model):
    doctors = models.ManyToManyField(Doctor, through='Reservation')
    name = models.TextField()

    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'


class Reservation(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE)
    symptom = models.TextField()
    reserved_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f'{self.doctor.pk}번 의사의 {self.patient.pk}번 환자'

# 1. Reservation class를 통한 예약 생성
reservation1 = Reservation(doctor=doctor1, patient=patient1, symptom='headache')
reservation1.save()
doctor1.patient_set.all()
patient1.doctors.all()

# 2. Patient 객체를 통한 예약 생성
# through_defaults 키워드 인자가 필요하며, dict로 넣어주기
patient2.doctors.add(doctor1, through_defaults={'symptom': 'flu'})
doctor1.patient_set.all()
patient2.doctors.all()

doctor1.patient_set.remove(patient1)
patient2.doctors.remove(doctor1)


M:N 관계 주요 사항
    - M:N 관계로 맺어진 두 테이블에는 물리적 변화 X
    - ManyToManyField는 중개 테이블을 자동으로 생성
    - ManyToManyField는 M:N 관계를 맺는 두 모델 어디에 위치해도 상관 X
    - N:1은 완전 종속 관계지만 M:N은 종속적인 관계가 아니며,
      의사에게 진찰받는 환자, 환자를 진찰하는 의사 이렇게 두가지 형태 모두 표현 가능 


ManyToManyField의 대표 인자 3가지
    - related_name  = 역참조시  사용하는 manager name 변경 
    - symmetrical   = 관계설정 시 대칭 유무 설정 / 기본값 : True 
    - through       = 사용하고자 하는 중개 모델 지정 일반적으로 M:N 관계 연결

ManyToManyField의 대표 조작 methods
    - add() 관계 추가
    - remove() 객체 제거 


# Create your models here.
class Article(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )
    like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_articles')
    title = models.CharField(max_length=10)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

like_users 필드 생성시 자동으로 역참조 매니저 .article_set이 생성되는데,
이미 같은 이름 Article-User 관계에서 사용중이므로 
related_name 으로 이름 재정의 필요 


User-Article간 사용 가능한 전체 related_manager
    - article.user          = 게시글 작성한 유저
    - user.article_set      = 유저가 작성한 게시글(역참조)
    - article.like_users    = 게시글을 좋아요 한 유저
    - user.like_articles    = 유저가 좋아요 한 게시글 




---------- dumpdata 만들기

게시글 dump
$ python manage.py dumpdata --indent 4 articles.article > articles.json

댓글 dump
$ python manage.py dumpdata --indent 4 articles.comment > comments.json

유저 dump
$ python manage.py dumpdata --indent 4 accounts.user > users.json

Fixtures 파일을 직접 만들지 마 ! 
app_name/fixtures/ 가 약속된 경로 

더미데이터 불러오기 
한방에 로드 가능 !! 
$ python manage.py loaddata articles.json users.json comments.json

python -Xutf8 manage.py dumpdata [생략]
Or
메모장 활용해서 메모장으로 json 열고 
다름이름으로 저장 클릭 
인코딩을 UTF8로 선택 후 저장 

 --------------------------------------------------------------------

더미데이터 최적화
    - 같은 결과를 얻기 위해 DB측에 보내는 query 개수 줄이기

    